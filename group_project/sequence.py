def most_nuc(a):#what if it has the same number/has two AUG:start
    dic={}
    start=[]#
    for i in range(len(a)-2):
        if a[i:i+3]=="AUG":
            start.append(i)#
    if start==[]:#
        return "NotFound1"
    j=0#记录前一个密码子结束的地点，如果它的位置在这个开始密码子后面或者两个A重合，这个密码子不算(除了i==0的情况)
    for k in range(len(start)):#
        i=start[k]#取每一个密码子开始位置 
        if j>=i and i!=0:
            continue
        while a[i:i+3] not in ["UAA","UAG","UGA"] and i+3<=len(a):
            if a[i: i+3] in dic:
                dic[a[i:i+3]]+=1
            else:
                dic[a[i:i+3]]=1
            i+=3
        j=i+3
    if dic=={}:
        return "NotFound2"
    m=max(dic.values())#可以先找出字典中的最大值，再一次性找出所有值等于最大值的键，这样代码逻辑更清晰
    q=[key for key,value in dic.items() if value==m]
    return q,dic
se="AUGGUGCUCCUCGUUGGACUGCCUCCGACUGGUGCUUCCUCGGACUUGGACUGCCUCCGACUGGUGCUUCCUCGGACUUGGACUGCCUCCGACUGGUGCUUCCUCGGACUUGGACUGCCUCCGACUGGUGCUUCCUCGGACUUGGACUGCCUCCGACUGGUGCUUCCUCGGACUUGGACUGCCUCCGACUGGUGCUUCCUCGGACUUGGACUGCCUCCGACUGGUGCUUCCUCGGACUUGGACUGCCUCCGACUGGUGCUUCCUCGGACUUGGACUGCCUCCGACUGGUGCUUCCUCGGACUUGGACUGCCUCCGACUGGUGCUUCCUCGGACUUGGACUGCCUCCGACUGGUGCUUCCUCGGACUUGGACUGCCUCCGACUGGUGCUUCCUCGGACUUGGACUGCCUCCGACUGGUGCUUCCUCGGACUUGGACUGCCUCCGACUGGUGCUUCCUCGGACUUGGACUGCCUCCGACUGGUGCUUCCUCGGACUUGGACUGCCUCCGACUGGUGCUUCCUCGGACUUGGACUGCCUCCGACUGGUGCUUCCUCGGACUUGGACUGCCUCCGACUGGUGCUUCCUCGGACUUGGACUGCCUCCGACUGGUGCUUCCUCGGACUUGGACUGCCUCCGACUGGUGCUUCCUCGGACUUGGACUGCCUCCGACUGGUGCUUCCUCGGACUUGGACUGCCUCCGACUGGUGCUUCCUCGGACUUGGACUGCCUCCGACUGGUGCUUCCUCGGACUUGGACUGCCUCCGACUGGUGCUUCCUCGGACUUGGACUGCCUCCGACUGGUGCUUCCUCGGACUUGGACUGCCUCCGACUGGUGCUUCCUCGGACUUGGACUGCCUCCGACUGGUGCUUCCUCGGACUUGGACUGCCUCCGACUGGUGCUUCCUCGGACUUGGACUGCCUCCGACUGGUGCUUCCUCGGACUUGGACUGCCUCCGACUGGUGCUUCCUCGGACUUGGACUGCCUCCGACUGGUGCUUCCUCGGACUUGGACUGCCUCCGACUGGUGCUUCCUCGGACUUGGACUGCCUCCGACUGGUGCUUCCUCGGACUUGGACUGCCUCCGACUGGUGCUUCCUCGGACUUGGACUGCCUCCGACUGGUGCUUCCUCGGACUUGGACUGCCUCCGACUGGUGCUUCCUCGGACUUGGACUGCCUCCGACUGGUGCUUCCUCGGACUUGGACUGCCUCCGACUGGUGCUUCCUCGGACUUGGACUGCCUCCGACUGGUGCUUCCUCGGACUUGGACUGCCUCCGACUGGUG"
print(most_nuc(se))

def trans(a):
     codon_table={'AUG': 'Met','CCG': 'Pro','UUU': 'Phe', 'UUC': 'Phe','UUA': 'Leu', 'UUG': 'Leu', 'CUU': 'Leu', 'CUC': 'Leu', 'CUA': 'Leu', 'CUG': 'Leu','AUU': 'Ile', 
                   'AUC': 'Ile', 'AUA': 'Ile', 'GUU': 'Val', 'GUC': 'Val', 'GUA': 'Val', 'GUG': 'Val','UCU': 'Ser', 'UCC': 'Ser', 'UCA': 'Ser', 'UCG': 'Ser','CCU': 'Pro', 
                   'CCC': 'Pro', 'CCA': 'Pro','ACU': 'Thr', 'ACC': 'Thr', 'ACA': 'Thr', 'ACG': 'Thr','GCU': 'Ala', 'GCC': 'Ala', 'GCA': 'Ala', 'GCG': 'Ala','UAU': 'Tyr', 
                   'UAC': 'Tyr','CAU': 'His', 'CAC': 'His', 'CAA': 'Gln', 'CAG': 'Gln','AAU': 'Asn', 'AAC': 'Asn','AAA': 'Lys', 'AAG': 'Lys', 'GAU': 'Asp', 'GAC': 'Asp',
                   'GAA': 'Glu', 'GAG': 'Glu','UGU': 'Cys', 'UGC': 'Cys', 'UGG': 'Trp', 'CGU': 'Arg', 'CGC': 'Arg', 'CGA': 'Arg', 'CGG': 'Arg', 'AGA': 'Arg', 'AGG': 'Arg',
                   'GGU': 'Gly', 'GGC': 'Gly', 'GGA': 'Gly', 'GGG': 'Gly'}
     if a not in codon_table.keys():
         return "Error"
     return codon_table[a]
def most_ami(a):
    q=most_nuc(a)[0]
    ami=[]
    for i in range(len(q)):
        ami.append(trans(q[i]))
    return ami
se="AUGGUGCUCCUCGUUGGACUGCCUCCGACUGGUGCUUCCUCGGACUUGGACUGCCUCCGACUGGUGCUUCCUCGGACUUGGACUGCCUCCGACUGGUGCUUCCUCGGACUUGGACUGCCUCCGACUGGUGCUUCCUCGGACUUGGACUGCCUCCGACUGGUGCUUCCUCGGACUUGGACUGCCUCCGACUGGUGCUUCCUCGGACUUGGACUGCCUCCGACUGGUGCUUCCUCGGACUUGGACUGCCUCCGACUGGUGCUUCCUCGGACUUGGACUGCCUCCGACUGGUGCUUCCUCGGACUUGGACUGCCUCCGACUGGUGCUUCCUCGGACUUGGACUGCCUCCGACUGGUGCUUCCUCGGACUUGGACUGCCUCCGACUGGUGCUUCCUCGGACUUGGACUGCCUCCGACUGGUGCUUCCUCGGACUUGGACUGCCUCCGACUGGUGCUUCCUCGGACUUGGACUGCCUCCGACUGGUGCUUCCUCGGACUUGGACUGCCUCCGACUGGUGCUUCCUCGGACUUGGACUGCCUCCGACUGGUGCUUCCUCGGACUUGGACUGCCUCCGACUGGUGCUUCCUCGGACUUGGACUGCCUCCGACUGGUGCUUCCUCGGACUUGGACUGCCUCCGACUGGUGCUUCCUCGGACUUGGACUGCCUCCGACUGGUGCUUCCUCGGACUUGGACUGCCUCCGACUGGUGCUUCCUCGGACUUGGACUGCCUCCGACUGGUGCUUCCUCGGACUUGGACUGCCUCCGACUGGUGCUUCCUCGGACUUGGACUGCCUCCGACUGGUGCUUCCUCGGACUUGGACUGCCUCCGACUGGUGCUUCCUCGGACUUGGACUGCCUCCGACUGGUGCUUCCUCGGACUUGGACUGCCUCCGACUGGUGCUUCCUCGGACUUGGACUGCCUCCGACUGGUGCUUCCUCGGACUUGGACUGCCUCCGACUGGUGCUUCCUCGGACUUGGACUGCCUCCGACUGGUGCUUCCUCGGACUUGGACUGCCUCCGACUGGUGCUUCCUCGGACUUGGACUGCCUCCGACUGGUGCUUCCUCGGACUUGGACUGCCUCCGACUGGUGCUUCCUCGGACUUGGACUGCCUCCGACUGGUGCUUCCUCGGACUUGGACUGCCUCCGACUGGUGCUUCCUCGGACUUGGACUGCCUCCGACUGGUGCUUCCUCGGACUUGGACUGCCUCCGACUGGUGCUUCCUCGGACUUGGACUGCCUCCGACUGGUGCUUCCUCGGACUUGGACUGCCUCCGACUGGUG"
print(most_ami(se))

def all_ami(a):
    ami=[]
    for i in range(len(a)):#len(most_nuc(se)[1])==len(a)
        ami.append(trans(a[i]))
    return ami
import matplotlib.pyplot as plt

plt.title('Amino Acid Frequency Distribution')
plt.xlabel('Amino Acid')
plt.ylabel('Frequency')
plt.bar(all_ami(list(most_nuc(se)[1].keys())),most_nuc(se)[1].values())
plt.tight_layout()
plt.show()
          
    